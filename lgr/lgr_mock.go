// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package lgr

import (
	"log/slog"
	"sync"
)

// Ensure, that ConfigMock does implement Config.
// If this is not the case, regenerate this file with moq.
var _ Config = &ConfigMock{}

// ConfigMock is a mock implementation of Config.
//
//	func TestSomethingThatUsesConfig(t *testing.T) {
//
//		// make and configure a mocked Config
//		mockedConfig := &ConfigMock{
//			IsWriteToFileFunc: func() bool {
//				panic("mock out the IsWriteToFile method")
//			},
//			LevelFunc: func() slog.Level {
//				panic("mock out the Level method")
//			},
//			OutputFormatFunc: func() string {
//				panic("mock out the OutputFormat method")
//			},
//			PathFunc: func() string {
//				panic("mock out the Path method")
//			},
//		}
//
//		// use mockedConfig in code that requires Config
//		// and then make assertions.
//
//	}
type ConfigMock struct {
	// IsWriteToFileFunc mocks the IsWriteToFile method.
	IsWriteToFileFunc func() bool

	// LevelFunc mocks the Level method.
	LevelFunc func() slog.Level

	// OutputFormatFunc mocks the OutputFormat method.
	OutputFormatFunc func() string

	// PathFunc mocks the Path method.
	PathFunc func() string

	// calls tracks calls to the methods.
	calls struct {
		// IsWriteToFile holds details about calls to the IsWriteToFile method.
		IsWriteToFile []struct {
		}
		// Level holds details about calls to the Level method.
		Level []struct {
		}
		// OutputFormat holds details about calls to the OutputFormat method.
		OutputFormat []struct {
		}
		// Path holds details about calls to the Path method.
		Path []struct {
		}
	}
	lockIsWriteToFile sync.RWMutex
	lockLevel         sync.RWMutex
	lockOutputFormat  sync.RWMutex
	lockPath          sync.RWMutex
}

// IsWriteToFile calls IsWriteToFileFunc.
func (mock *ConfigMock) IsWriteToFile() bool {
	if mock.IsWriteToFileFunc == nil {
		panic("ConfigMock.IsWriteToFileFunc: method is nil but Config.IsWriteToFile was just called")
	}
	callInfo := struct {
	}{}
	mock.lockIsWriteToFile.Lock()
	mock.calls.IsWriteToFile = append(mock.calls.IsWriteToFile, callInfo)
	mock.lockIsWriteToFile.Unlock()
	return mock.IsWriteToFileFunc()
}

// IsWriteToFileCalls gets all the calls that were made to IsWriteToFile.
// Check the length with:
//
//	len(mockedConfig.IsWriteToFileCalls())
func (mock *ConfigMock) IsWriteToFileCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockIsWriteToFile.RLock()
	calls = mock.calls.IsWriteToFile
	mock.lockIsWriteToFile.RUnlock()
	return calls
}

// Level calls LevelFunc.
func (mock *ConfigMock) Level() slog.Level {
	if mock.LevelFunc == nil {
		panic("ConfigMock.LevelFunc: method is nil but Config.Level was just called")
	}
	callInfo := struct {
	}{}
	mock.lockLevel.Lock()
	mock.calls.Level = append(mock.calls.Level, callInfo)
	mock.lockLevel.Unlock()
	return mock.LevelFunc()
}

// LevelCalls gets all the calls that were made to Level.
// Check the length with:
//
//	len(mockedConfig.LevelCalls())
func (mock *ConfigMock) LevelCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockLevel.RLock()
	calls = mock.calls.Level
	mock.lockLevel.RUnlock()
	return calls
}

// OutputFormat calls OutputFormatFunc.
func (mock *ConfigMock) OutputFormat() string {
	if mock.OutputFormatFunc == nil {
		panic("ConfigMock.OutputFormatFunc: method is nil but Config.OutputFormat was just called")
	}
	callInfo := struct {
	}{}
	mock.lockOutputFormat.Lock()
	mock.calls.OutputFormat = append(mock.calls.OutputFormat, callInfo)
	mock.lockOutputFormat.Unlock()
	return mock.OutputFormatFunc()
}

// OutputFormatCalls gets all the calls that were made to OutputFormat.
// Check the length with:
//
//	len(mockedConfig.OutputFormatCalls())
func (mock *ConfigMock) OutputFormatCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockOutputFormat.RLock()
	calls = mock.calls.OutputFormat
	mock.lockOutputFormat.RUnlock()
	return calls
}

// Path calls PathFunc.
func (mock *ConfigMock) Path() string {
	if mock.PathFunc == nil {
		panic("ConfigMock.PathFunc: method is nil but Config.Path was just called")
	}
	callInfo := struct {
	}{}
	mock.lockPath.Lock()
	mock.calls.Path = append(mock.calls.Path, callInfo)
	mock.lockPath.Unlock()
	return mock.PathFunc()
}

// PathCalls gets all the calls that were made to Path.
// Check the length with:
//
//	len(mockedConfig.PathCalls())
func (mock *ConfigMock) PathCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockPath.RLock()
	calls = mock.calls.Path
	mock.lockPath.RUnlock()
	return calls
}
